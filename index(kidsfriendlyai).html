<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friendly AI Pal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            background: #87CEEB; /* Sky Blue */
            height: 100vh;
            color: #333333; /* Dark Gray for text */
            overflow: hidden;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-text-size-adjust: 100%;
            -webkit-font-smoothing: antialiased;
        }

        .app-container {
            height: 95vh; /* Adjusted for a bit of margin */
            width: 100%;
            max-width: 600px; /* Kid-friendly width */
            margin: 0 auto;
            background: #FFFFFF; /* White chat background */
            border-radius: 20px; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Header */
        .header {
            background: #FFD700; /* Gold/Yellow */
            color: #4A4A4A; /* Darker text for contrast */
            padding: 15px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 2px solid #FFA500; /* Orange border */
            min-height: 70px;
            flex-shrink: 0;
            position: relative;
            z-index: 100;
        }

        .header h1 {
            font-size: 1.8em;
            font-weight: bold;
            margin: 0;
            flex: 1;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .tts-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1em;
        }
        
        .tts-toggle span {
            font-size: 1.5em; /* Larger emoji */
        }

        .toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: #FFBDA3; /* Light Orange */
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #FFA500;
        }

        .toggle-switch.active {
            background: #90EE90; /* Light Green */
        }

        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: #FFFFFF; /* White */
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(30px);
            background: #FFFFFF;
        }

        .settings-btn {
            background: #FFA500; /* Orange */
            border: none;
            color: #FFFFFF; /* White */
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .settings-btn:hover {
            background: #FF8C00; /* Darker Orange */
            transform: scale(1.05);
        }

        /* Chat Area */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #F0F8FF; /* Alice Blue - very light blue */
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .message {
            max-width: 80%;
            padding: 12px 18px;
            border-radius: 20px;
            word-wrap: break-word;
            line-height: 1.5;
            animation: messageSlide 0.3s ease-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(15px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            align-self: flex-end;
            background: #ADD8E6; /* Light Blue */
            color: #333;
            border-bottom-right-radius: 8px;
        }

        .message.assistant {
            align-self: flex-start;
            background: #FFFACD; /* Lemon Chiffon */
            color: #333;
            border-bottom-left-radius: 8px;
            position: relative;
        }

        .message.system {
            align-self: center;
            background: #E0E0E0; /* Light Gray */
            color: #555; /* Darker Gray */
            border: 1px dashed #AAAAAA;
            font-size: 0.9em;
            max-width: 90%;
            text-align: center;
            padding: 10px 15px;
            border-radius: 10px;
        }
        
        .message-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.5); /* Semi-transparent white */
            border: 1px solid #FFB6C1; /* Light Pink */
            color: #FF69B4; /* Hot Pink */
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 8px;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #FFB6C1; /* Light Pink */
            color: #FFFFFF;
        }


        /* Input Area */
        .input-container {
            padding: 15px 20px;
            background: #FFFFFF; /* White */
            border-top: 2px solid #FFA500; /* Orange border */
            position: relative;
            z-index: 1;
        }

        .input-wrapper {
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }

        .message-input {
            flex: 1;
            min-height: 48px;
            max-height: 100px;
            padding: 12px 16px;
            border: 2px solid #ADD8E6; /* Light Blue */
            border-radius: 12px;
            font-size: 16px;
            resize: none;
            font-family: inherit;
            line-height: 1.5;
            background: #F0F8FF; /* Alice Blue */
            color: #333333;
        }

        .message-input::placeholder {
            color: #777777; /* Medium Gray */
        }

        .message-input:focus {
            outline: none;
            border-color: #FFC0CB; /* Pink */
            box-shadow: 0 0 0 3px rgba(255, 192, 203, 0.4); /* Pink glow */
        }

        .input-area-buttons {
            display: flex;
            gap: 8px;
        }
        
        .mic-btn,
        .send-btn {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 12px; /* Rounded */
            background: #FF6347; /* Tomato Red */
            color: #FFFFFF; /* White icon/text */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em; /* Larger emoji */
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        .mic-btn.listening { /* Style for when mic is active */
            background: #FF0000; /* Red when listening */
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }


        .send-btn:hover:not(:disabled), .mic-btn:hover:not(.listening) {
            transform: scale(1.1);
            background: #FF4500; /* OrangeRed */
        }
        .mic-btn.listening:hover {
            background: #CC0000; /* Darker red when listening and hovered */
        }


        .send-btn:disabled {
            opacity: 0.6;
            background: #D3D3D3; /* Light Gray */
            cursor: not-allowed;
            transform: none;
        }
        .mic-btn:disabled { /* Separate disabled style for mic if needed */
            opacity: 0.6;
            background: #D3D3D3;
            cursor: not-allowed;
            transform: none;
            animation: none;
        }


        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-content {
            background: #FFFFFF; /* White */
            border-radius: 15px;
            padding: 30px;
            width: 100%;
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            border: 3px solid #FFA500; /* Orange */
            color: #333333;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            position: relative;
            z-index: 1001;
        }

        .modal h2 {
            margin-bottom: 25px;
            color: #FF6347; /* Tomato Red */
            text-align: center;
            font-size: 1.8em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555555; /* Dark Gray */
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ADD8E6; /* Light Blue */
            border-radius: 10px;
            font-size: 16px;
            background: #F0F8FF; /* Alice Blue */
            color: #333333;
        }

        .form-group input:focus {
            outline: none;
            border-color: #FFC0CB; /* Pink */
            box-shadow: 0 0 0 3px rgba(255, 192, 203, 0.4); /* Pink glow */
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            justify-content: space-between; /* Added for spacing buttons */
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .btn-primary {
            background: #32CD32; /* Lime Green */
            color: #FFFFFF;
        }
        .btn-primary:hover {
            background: #228B22; /* Forest Green */
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #FF6347; /* Tomato Red */
            color: #FFFFFF;
        }
        .btn-secondary:hover {
            background: #CD5C5C; /* Indian Red */
            transform: translateY(-2px);
        }
        
        .btn-tertiary { /* New style for clear history button */
            background: #ADD8E6; /* Light Blue */
            color: #333;
            border: 1px solid #6495ED; /* Cornflower Blue */
        }
        .btn-tertiary:hover {
            background: #87CEEB; /* Sky Blue */
            transform: translateY(-2px);
        }

        /* Loading indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 18px;
            background: #FFFACD; /* Lemon Chiffon, similar to assistant */
            border: 1px dashed #F0E68C; /* Khaki */
            border-radius: 20px;
            border-bottom-left-radius: 8px;
            align-self: flex-start;
            max-width: fit-content;
            font-style: italic;
            color: #555;
        }

        .typing-dots {
            display: flex;
            gap: 5px;
        }

        .typing-dot {
            width: 10px;
            height: 10px;
            background: #FFC0CB; /* Pink */
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-8px);
                opacity: 1;
            }
        }

        /* Custom Scrollbars */
        ::-webkit-scrollbar {
            width: 12px;
        }
        ::-webkit-scrollbar-track {
            background: #E0F7FA; /* Very light cyan */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #FFB6C1; /* Light Pink */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #FF69B4; /* Hot Pink */
        }
        * { /* For Firefox */
            scrollbar-width: auto; /* Or 'thin' */
            scrollbar-color: #FFB6C1 #E0F7FA; /* thumb track */
        }

        .hidden { display: none !important; }

        /* Mobile Optimizations - General adjustments for a kid-friendly theme */
        @media (max-width: 768px) {
            .app-container {
                height: 100vh;
                border-radius: 0;
                box-shadow: none;
            }
            .header {
                padding: 12px 15px;
                min-height: 65px;
            }
            .header h1 { font-size: 1.5em; }
            .message { max-width: 90%; font-size: 1em; }
            .input-container { padding: 10px 15px; }
            .message-input { font-size: 15px; }
            .mic-btn, .send-btn { width: 44px; height: 44px; font-size: 1.3em; }
            .modal-content { margin: 10px; padding: 20px; }
        }

        @media (max-width: 480px) {
            .header { padding: 10px 12px; min-height: 60px; }
            .header h1 { font-size: 1.2em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            .tts-toggle span { font-size: 1.3em; } /* Keep emoji visible */
            .settings-btn { font-size: 0.9em; padding: 8px 10px; }
            .chat-messages { padding: 10px; }
            .message { max-width: 92%; font-size: 0.95em; padding: 10px 14px; border-radius: 15px; }
            .message.user { border-bottom-right-radius: 6px; }
            .message.assistant { border-bottom-left-radius: 6px; }
            .input-container { padding: 8px 10px; }
            .message-input { font-size: 14px; max-height: 90px; }
            .mic-btn, .send-btn { width: 40px; height: 40px; font-size: 1.2em; }
            .modal h2 { font-size: 1.5em; }
            .form-group input { font-size: 14px; }
            .btn { font-size: 15px; padding: 10px 12px; }
            .modal-buttons { flex-direction: column; } /* Stack buttons on small screens */
            .btn { width: 100%; margin-bottom: 10px; }
            .btn:last-child { margin-bottom: 0; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üé® Friendly AI Pal</h1>
            <div class="header-controls">
                <div class="tts-toggle">
                    <span>üîä</span>
                    <div class="toggle-switch" id="ttsToggle">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <button class="settings-btn" id="settingsBtn">‚öôÔ∏è Setup</button>
            </div>
        </div>

        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                </div>

            <div class="input-container">
                <div class="input-wrapper">
                    <textarea 
                        id="messageInput" 
                        class="message-input" 
                        placeholder="Ask me something..."
                        rows="1"
                    ></textarea>
                    <div class="input-area-buttons">
                        <button id="micBtn" class="mic-btn" title="Speak to type">üé§</button>
                        <button id="sendBtn" class="send-btn" title="Send message">‚û§</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <h2>‚öôÔ∏è Super Setup Page!</h2>
            <div class="form-group">
                <label for="apiKeyInput">Your Grown-Up's OpenRouter API Key:</label>
                <input 
                    type="password" 
                    id="apiKeyInput" 
                    placeholder="Ask a grown-up for this code!"
                    autocomplete="off">
            </div>
            <div class="form-group">
                <label for="systemPromptInput">How I Should Behave (System Prompt):</label>
                <input 
                    type="text" 
                    id="systemPromptInput" 
                    placeholder="Example: You are a super fun and silly robot!"
                    value="You are Pal, a very friendly, cheerful, and patient AI assistant for kids. Explain things simply and use fun examples. Never use emojis or action descriptions (like *smiles*).">
            </div>
            <div class="modal-buttons">
                <button class="btn btn-tertiary" id="clearHistoryBtn">Clear Chat History</button>
                <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
                <button class="btn btn-primary" id="saveBtn">Save & Play!</button>
            </div>
        </div>
    </div>

    <script type="module">
        // VITS-Web TTS Class (with improved voice loading and error handling)
        class VITSWeb {
            constructor() {
                this.isInitialized = false;
                this.audioContext = null;
                this.voices = [];
                this._initializeVoices(); // Start loading voices
            }

            async _initializeVoices() {
                return new Promise((resolve) => {
                    if (!('speechSynthesis' in window)) {
                        console.warn('[TTS-Init] Speech synthesis not supported by this browser.');
                        resolve();
                        return;
                    }
                    
                    const tryGetVoices = () => {
                        this.voices = speechSynthesis.getVoices();
                        if (this.voices.length > 0) {
                            console.log(`[TTS-Init] Voices available: ${this.voices.length}`);
                            if (speechSynthesis.onvoiceschanged === tryGetVoices) { // Remove listener if it was set
                                speechSynthesis.onvoiceschanged = null;
                            }
                            resolve();
                            return true;
                        }
                        return false;
                    }

                    if (tryGetVoices()) return; // Voices might be ready immediately

                    speechSynthesis.onvoiceschanged = tryGetVoices;
                    
                     // Fallback timeout if onvoiceschanged isn't fired reliably in some browsers/scenarios
                    setTimeout(() => {
                        if (this.voices.length === 0) { // If still no voices after event and some delay
                           console.warn("[TTS-Init] onvoiceschanged not fired or no voices after delay, trying final fetch.");
                           tryGetVoices(); // One last attempt
                        }
                        if (speechSynthesis.onvoiceschanged === tryGetVoices) { // Clean up if our timeout resolves it first
                            speechSynthesis.onvoiceschanged = null;
                        }
                        resolve(); // Resolve anyway, synthesize will check voices length
                    }, 1000); // Increased timeout for slower systems
                });
            }

            async initialize() {
                if (this.isInitialized) return true;
                console.log("[TTS-Init] Initializing VITSWeb...");
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    await this._initializeVoices(); // Ensure voices are loaded/attempted
                    this.isInitialized = true;
                    console.log(`[TTS-Init] VITSWeb initialized. Voices available: ${this.voices.length}`);
                    return true;
                } catch (error) {
                    console.error('[TTS-Init] Failed to initialize VITS (AudioContext or Voices):', error);
                    this.isInitialized = false;
                    return false;
                }
            }

            async synthesize(text) {
                if (!this.isInitialized) {
                    const success = await this.initialize();
                    if (!success) {
                        console.error("[TTS] Initialization failed in synthesize. Cannot synthesize.");
                        return Promise.reject(new Error('TTS initialization failed. Cannot synthesize.'));
                    }
                }
            
                console.log(`[TTS] Synthesize called. Text (start): "${text.substring(0, 70)}..." Length: ${text.length}`);
            
                return new Promise((resolve, reject) => {
                    if (!('speechSynthesis' in window)) {
                        console.error("[TTS] Speech synthesis API not supported in this browser.");
                        reject(new Error('Speech synthesis not supported.'));
                        return;
                    }
            
                    if (this.voices.length === 0) {
                        console.warn("[TTS] No voices loaded at the time of synthesis. Attempting a last-minute fetch.");
                        this.voices = speechSynthesis.getVoices(); // One last try
                        if (this.voices.length === 0) {
                            console.error("[TTS] Still no voices available after re-fetch.");
                            reject(new Error('No speech synthesis voices available.'));
                            return;
                        }
                        console.log(`[TTS] Voices re-fetched: ${this.voices.length} voices found.`);
                    }
            
                    const utterance = new SpeechSynthesisUtterance(text);
            
                    const preferredVoices = [
                        'Google US English', 'Microsoft Zira - English (United States)', // Common good quality
                        'Microsoft David - English (United States)', // Male alternative
                        'Google UK English Female', 'Google UK English Male',
                        'Samantha', // Often on Apple devices
                        'Alex', // Often on Apple devices
                         // Add any other known good voices
                    ];
                    let selectedVoice = null;
            
                    // Try to find a preferred, high-quality voice
                    for (const preferred of preferredVoices) {
                        selectedVoice = this.voices.find(voice => voice.name === preferred && voice.lang.toLowerCase().startsWith('en-'));
                        if (selectedVoice) break;
                    }
                    
                    // Broader search if specific preferred not found
                    if (!selectedVoice) {
                        selectedVoice = this.voices.find(voice => voice.lang.toLowerCase().startsWith('en-us') && voice.localService && voice.name.toLowerCase().includes('female'));
                    }
                    if (!selectedVoice) {
                        selectedVoice = this.voices.find(voice => voice.lang.toLowerCase().startsWith('en-us') && voice.localService);
                    }
                    if (!selectedVoice) { // Fallback to any default English voice
                        selectedVoice = this.voices.find(voice => voice.lang.toLowerCase().startsWith('en-') && voice.default);
                    }
                    if (!selectedVoice) { // Any English voice
                        selectedVoice = this.voices.find(voice => voice.lang.toLowerCase().startsWith('en-'));
                    }
                    if (!selectedVoice && this.voices.length > 0) { // Absolute fallback
                        selectedVoice = this.voices.find(voice => voice.lang.toLowerCase().startsWith('en-')) || this.voices[0];
                    }
            
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                        console.log(`[TTS] Voice selected: ${selectedVoice.name} (Lang: ${selectedVoice.lang}, Default: ${selectedVoice.default}, Local: ${selectedVoice.localService})`);
                    } else {
                        console.warn('[TTS] No specific voice found after selection logic. Using system default if available.');
                    }
            
                    utterance.rate = 0.95; 
                    utterance.pitch = 1.05; 
                    utterance.volume = 0.9;  
            
                    let lastCharIndexSpoken = 0;
            
                    utterance.onstart = () => {
                        console.log(`[TTS] Speech STARTED. Voice: ${utterance.voice ? utterance.voice.name : 'Default'} (${utterance.voice ? utterance.voice.lang : 'N/A'}). Text (start): "${text.substring(0, 70)}..."`);
                    };
            
                    utterance.onboundary = (event) => {
                        if (event.name === 'word') {
                            lastCharIndexSpoken = event.charIndex + event.charLength;
                            // console.log(`[TTS] Boundary: Word "${text.substring(event.charIndex, lastCharIndexSpoken)}" at char ${event.charIndex}`);
                        }
                    };
            
                    utterance.onend = () => {
                        console.log(`[TTS] Speech ENDED. Last char index spoken: ${lastCharIndexSpoken}. Total text length: ${text.length}.`);
                        if (lastCharIndexSpoken < text.length - 5 && text.length > 10) { 
                            console.warn(`[TTS] POTENTIAL CUT-OFF: Speech ended, but last char index (${lastCharIndexSpoken}) is significantly less than text length (${text.length}).`);
                        }
                        resolve();
                    };
            
                    utterance.onerror = (event) => {
                        console.error(`[TTS] Speech ERROR: ${event.error}. Voice: ${utterance.voice ? utterance.voice.name : 'Default'}. Text (start): "${text.substring(0, 70)}..."`);
                        console.error(`[TTS] Full error event:`, event);
                        reject(new Error(`TTS failed: ${event.error}`));
                    };
            
                    if (speechSynthesis.speaking || speechSynthesis.pending) {
                        console.log("[TTS] Speech synthesis is currently speaking or has pending utterances. Cancelling previous.");
                        speechSynthesis.cancel(); // This should clear the queue and stop current speech.
                    }
            
                    // A brief timeout *can* sometimes help if cancel() itself is buggy or takes a moment to process in the browser.
                    // This is usually a sign of a browser quirk. Test without it first.
                    setTimeout(() => {
                        console.log("[TTS] Attempting to speak (after ensuring cancel had a moment if it was called)...");
                        speechSynthesis.speak(utterance);
                    }, 50); // 50ms delay; adjust or remove if not needed. If speech gets cut *more*, this might be too aggressive with some engines.
                           // Or, if it helps, it points to a timing issue with cancel/speak.

                    // Alternatively, if the timeout causes issues:
                    // console.log("[TTS] Attempting to speak directly after cancel check...");
                    // speechSynthesis.speak(utterance);
                });
            }

            stop() {
                if ('speechSynthesis' in window) {
                    console.log('[TTS] Stop called. Cancelling speech.');
                    speechSynthesis.cancel();
                }
            }
        }

        // App State
        const appState = {
            apiKey: '',
            systemPrompt: "You are Pal, a very friendly, cheerful, and patient AI assistant for kids. Explain things simply and use fun examples. Never use emojis or action descriptions (like *smiles*).", // Modified prompt
            ttsEnabled: true,
            messages: []
        };

        const LOCAL_STORAGE_KEY_API = 'friendlyAIPalApiKey';
        const LOCAL_STORAGE_KEY_PROMPT = 'friendlyAIPalSystemPrompt';
        const LOCAL_STORAGE_KEY_TTS = 'friendlyAIPalTTSEnabled';
        const LOCAL_STORAGE_KEY_MESSAGES = 'friendlyAIPalMessages';

        // Initialize components
        const vits = new VITSWeb();
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const micBtn = document.getElementById('micBtn');
        const ttsToggle = document.getElementById('ttsToggle');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const systemPromptInput = document.getElementById('systemPromptInput');
        const saveBtn = document.getElementById('saveBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const clearHistoryBtn = document.getElementById('clearHistoryBtn'); // New button
        
        let isRecognizing = false; // For speech recognition state

        // Message Management
        function addMessage(content, role, speak = false, save = true) { // Added save parameter
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            messageDiv.textContent = content; // Use textContent for safety against XSS with plain text

            if (role === 'assistant') {
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'message-controls';
                controlsDiv.innerHTML = `
                    <button class="control-btn" data-speak-message title="Speak message again">üîä</button>
                    <button class="control-btn" data-copy-message title="Copy message">üìã</button>
                `;
                messageDiv.appendChild(controlsDiv);
            }

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            if (speak && appState.ttsEnabled && role === 'assistant') {
                const textToSpeak = messageDiv.cloneNode(true);
                const controls = textToSpeak.querySelector('.message-controls');
                if (controls) controls.remove(); // Remove controls before getting text content for speech
                speakText(textToSpeak.textContent || content);
            }
            if (save) { // Only save if not a temporary system message
                appState.messages.push({ role, content });
                saveChatHistory(); // Save after each message
            }
        }
        
        // Event delegation for message controls
        chatMessages.addEventListener('click', function(event) {
            const target = event.target;
            const messageDiv = target.closest('.message.assistant');
            if (!messageDiv) return;

            const textNode = messageDiv.cloneNode(true);
            const controls = textNode.querySelector('.message-controls');
            if (controls) controls.remove();
            const textContent = textNode.textContent || "";

            if (target.matches('[data-speak-message]')) {
                speakText(textContent);
            } else if (target.matches('[data-copy-message]')) {
                 navigator.clipboard.writeText(textContent).then(() => {
                    target.textContent = '‚úì';
                    setTimeout(() => target.textContent = 'üìã', 1500);
                }).catch(err => console.error("Failed to copy text: ", err));
            }
        });


        function showTypingIndicator() {
            const typingDiv = document.createElement('div');
            typingDiv.className = 'typing-indicator';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = `
                <span>Pal is thinking...</span>
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            chatMessages.appendChild(typingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function hideTypingIndicator() {
            const typing = document.getElementById('typingIndicator');
            if (typing) typing.remove();
        }

        // TTS Functions
        async function speakText(text) {
            if (!text || text.trim() === "") {
                console.log("[SpeakText] Empty text, not speaking.");
                return;
            }
            console.log("[SpeakText] Requesting to speak text:", text.substring(0,50) + "...");
            try {
                await vits.synthesize(text);
            } catch (error) {
                console.error('[SpeakText] TTS Error from speakText:', error);
                // addMessage(`Oh dear! My voice box had a little hiccup trying to speak. Error: ${error.message}`, 'system');
            }
        }

        // OpenRouter API Integration
        async function sendToOpenRouter(userMessage) {
            if (!appState.apiKey) {
                throw new Error('Please ask a grown-up to configure the OpenRouter API key in "Setup" first!');
            }

            const messagesForAPI = [
                { role: 'system', content: appState.systemPrompt },
                ...appState.messages.slice(-8).map(msg => ({role: msg.role, content: msg.content})), // Keep last 8 messages
                { role: 'user', content: userMessage }
            ];

            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${appState.apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.origin || 'https://my-ai-pal.com', 
                        'X-Title': 'Friendly AI Pal',
                    },
                    body: JSON.stringify({
                        model: 'deepseek/deepseek-chat', // Or use a different model available on OpenRouter
                        messages: messagesForAPI,
                        temperature: 0.6,
                        max_tokens: 1000,
                        stream: false 
                    })
                });

                if (!response.ok) {
                    let errorMessage = `Oops! HTTP Error ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error?.message || errorMessage;
                    } catch (e) { /* Ignore if error data isn't json */ }
                    throw new Error(errorMessage);
                }
                const data = await response.json();
                return data.choices[0].message.content;

            } catch (error) {
                console.error("[API Error] sendToOpenRouter failed:", error);
                if (error.name === 'TypeError' && error.message.toLowerCase().includes('failed to fetch')) {
                     throw new Error('‚ö†Ô∏è Network Hiccup! I couldn\'t reach my brain (OpenRouter API). Please check your internet connection or if you are running this from a local file, there might be CORS issues. Running from a local server (like "http://localhost:...") is best! The `file:///` protocol often blocks these kinds of requests.');
                } else {
                    throw error;
                }
            }
        }
        
        function getDemoResponse(userMessage) {
            const responses = [
                "I'm Pal, your AI friend! Right now, I'm in a special demo mode. To chat for real, a grown-up needs to help set up my API key!",
                "That's a super question! In demo mode, I can't give full answers. If you run this from your own computer (not just the preview), I can talk properly!",
                "I'd love to tell you more! But this is just a sneak peek. For my full brainpower, please ask a grown-up to follow the setup steps.",
            ];
            const randomResponse = responses[Math.floor(Math.random() * responses.length)];
            return randomResponse + `\n\nüí° **Grown-ups:**\n1. Copy this HTML.\n2. Save as a .html file.\n3. Open in a browser from a local server or directly.\n4. Click 'Setup' to add your OpenRouter API key.`;
        }


        // Chat Functions
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            messageInput.value = '';
            adjustTextareaHeight();

            showTypingIndicator();
            sendBtn.disabled = true;
            micBtn.disabled = true;

            try {
                let response;
                if (appState.apiKey) {
                    try {
                        response = await sendToOpenRouter(message);
                    } catch (error) {
                        hideTypingIndicator();
                        // This message should not be saved to history as it's an error feedback
                        addMessage(error.message, 'system', false, false); 
                        
                        // Offer demo response after API failure
                        showTypingIndicator();
                        await new Promise(resolve => setTimeout(resolve, 1500)); // Wait a bit
                        hideTypingIndicator();
                        // This demo response should also not be saved to history
                        const demoResponse = getDemoResponse(message);
                        addMessage(demoResponse, 'assistant', true, false); 
                        return;
                    }
                } else {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate thinking for demo
                    // This demo response should not be saved to history
                    response = getDemoResponse(message);
                }
                
                hideTypingIndicator();
                addMessage(response, 'assistant', true);
                
            } catch (error) {
                hideTypingIndicator();
                // This message should not be saved to history
                addMessage(`D'oh! A little glitch happened: ${error.message}`, 'system', false, false);
            } finally {
                sendBtn.disabled = false;
                micBtn.disabled = false;
                if(!isRecognizing) messageInput.focus();
            }
        }

        // UI Event Handlers
        function adjustTextareaHeight() {
            messageInput.style.height = 'auto';
            messageInput.style.height = Math.min(messageInput.scrollHeight, 100) + 'px'; // Max height 100px
        }

        function toggleTTS() {
            appState.ttsEnabled = !appState.ttsEnabled;
            ttsToggle.classList.toggle('active', appState.ttsEnabled);
            if (!appState.ttsEnabled) {
                vits.stop(); // Stop any current speech if TTS is turned off
            }
            localStorage.setItem(LOCAL_STORAGE_KEY_TTS, appState.ttsEnabled); // Save TTS preference
            console.log(`TTS Enabled: ${appState.ttsEnabled}`);
        }

        function showSettings() {
            apiKeyInput.value = appState.apiKey;
            systemPromptInput.value = appState.systemPrompt;
            settingsModal.classList.remove('hidden');
        }

        function hideSettings() {
            settingsModal.classList.add('hidden');
        }

        function saveSettings() {
            appState.apiKey = apiKeyInput.value.trim();
            // Ensure the hardcoded prompt override behavior is removed here, it should only be set initially.
            // When saving, we use the value from the input directly.
            appState.systemPrompt = systemPromptInput.value.trim() || "You are Pal, a very friendly, cheerful, and patient AI assistant for kids. Explain things simply and use fun examples. Never use emojis or action descriptions (like *smiles*).";
            
            localStorage.setItem(LOCAL_STORAGE_KEY_API, appState.apiKey);
            localStorage.setItem(LOCAL_STORAGE_KEY_PROMPT, appState.systemPrompt);
            
            hideSettings();
            if (appState.apiKey) {
                addMessage('‚ú® Hooray! API key is set. I\'m ready to chat properly now!', 'system', false, false); // Don't save this system message
            } else {
                addMessage('üîë API key not set. I\'ll still be in demo mode. Ask a grown-up to add it in "Setup"!', 'system', false, false); // Don't save this system message
            }
        }

        function clearChatHistory() {
            if (confirm("Are you sure you want to clear all chat history? This cannot be undone!")) {
                appState.messages = [];
                localStorage.removeItem(LOCAL_STORAGE_KEY_MESSAGES);
                chatMessages.innerHTML = ''; // Clear display
                addMessage('üëã Hi there, little explorer! I\'m your friendly AI Pal. Let\'s chat and have some fun!', 'system', false, false);
                addMessage('Remember to ask a grown-up to help you set up the API key in the \'Setup\' button.', 'system', false, false);
                hideSettings();
            }
        }

        // Local Storage Management
        function loadSettingsAndHistory() {
            const storedApiKey = localStorage.getItem(LOCAL_STORAGE_KEY_API);
            const storedSystemPrompt = localStorage.getItem(LOCAL_STORAGE_KEY_PROMPT);
            const storedTtsEnabled = localStorage.getItem(LOCAL_STORAGE_KEY_TTS);
            const storedMessages = localStorage.getItem(LOCAL_STORAGE_KEY_MESSAGES);

            if (storedApiKey) {
                appState.apiKey = storedApiKey;
            }
            if (storedSystemPrompt) {
                appState.systemPrompt = storedSystemPrompt;
            }
            if (storedTtsEnabled !== null) {
                appState.ttsEnabled = storedTtsEnabled === 'true';
            }

            if (storedMessages) {
                try {
                    appState.messages = JSON.parse(storedMessages);
                    if (!Array.isArray(appState.messages)) { // Validate parsed data
                        appState.messages = [];
                        console.warn("Stored messages were not an array, resetting chat history.");
                    }
                } catch (e) {
                    console.error("Failed to parse stored messages, resetting.", e);
                    appState.messages = [];
                }
            } else {
                appState.messages = []; // Initialize as empty array if nothing stored
            }
        }

        function saveChatHistory() {
            localStorage.setItem(LOCAL_STORAGE_KEY_MESSAGES, JSON.stringify(appState.messages));
        }

        function renderChatHistory() {
            chatMessages.innerHTML = ''; // Clear existing messages
            if (appState.messages.length === 0) {
                // Display initial system messages if no history
                addMessage('üëã Hi there, little explorer! I\'m your friendly AI Pal. Let\'s chat and have some fun!', 'system', false, false);
                addMessage('Remember to ask a grown-up to help you set up the API key in the \'Setup\' button.', 'system', false, false);
            } else {
                appState.messages.forEach(msg => {
                    // Re-render messages, but don't speak them on load
                    addMessage(msg.content, msg.role, false, false); // Don't save again, don't speak
                });
            }
        }

        // Speech Recognition (Speak to Text)
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US'; 
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            micBtn.addEventListener('click', () => {
                if (isRecognizing) {
                    recognition.stop();
                     // isRecognizing will be set to false in recognition.onend
                } else {
                    if (!appState.apiKey && appState.messages.length > 3) { // Simple rate limit for demo STT
                        // addMessage("üé§ Please set up the API key to use the microphone more!", "system");
                        // return;
                    }
                    try {
                        recognition.start();
                    } catch (e) {
                        console.error("Error starting speech recognition:", e.message);
                        if (e.name === 'InvalidStateError') {
                             addMessage("üé§ My ears are a bit busy! Try again in a moment.", "system", false, false); // Don't save this message
                        } else {
                             addMessage("Oh no! My ears (microphone) aren't working right now. Maybe check permissions?", "system", false, false); // Don't save this message
                        }
                         isRecognizing = false;
                         micBtn.classList.remove('listening');
                         micBtn.textContent = 'üé§';
                         micBtn.title = "Speak to type";
                         micBtn.disabled = false;
                         sendBtn.disabled = false;
                    }
                }
            });

            recognition.onstart = () => {
                isRecognizing = true;
                micBtn.classList.add('listening');
                micBtn.textContent = 'ü§´'; 
                micBtn.title = "Stop listening";
                micBtn.disabled = false; // Keep mic button enabled to allow stopping
                sendBtn.disabled = true; 
                console.log("[STT] Recognition started.");
            };

            recognition.onresult = (event) => {
                const speechResult = event.results[0][0].transcript;
                console.log("[STT] Speech recognized:", speechResult);
                messageInput.value += (messageInput.value.length > 0 && !messageInput.value.endsWith(' ') ? ' ' : '') + speechResult;
                adjustTextareaHeight();
                messageInput.focus();
                // Consider auto-sending:
                // sendMessage(); 
            };

            recognition.onerror = (event) => {
                console.error('[STT] Speech recognition error:', event.error, event.message);
                let friendlyError = `Hmm, I couldn't understand that. Error: ${event.error}.`;
                if (event.error === 'no-speech') {
                    friendlyError = "I didn't hear anything! Try speaking a bit louder? üòä";
                } else if (event.error === 'audio-capture') {
                    friendlyError = "It seems my microphone isn't working. Is it connected and allowed by the browser/OS?";
                } else if (event.error === 'not-allowed') {
                    friendlyError = "I need permission to use the microphone! Please ask a grown-up to allow it in the browser settings. üé§";
                } else if (event.error === 'network') {
                    friendlyError = "Oh dear, a network issue is preventing my ears from working. Check your internet!";
                } else if (event.error === 'aborted') {
                    friendlyError = "Looks like speech input was stopped. Try again!";
                }
                addMessage(friendlyError, 'system', false, false); // Don't save this message
            };

            recognition.onend = () => {
                isRecognizing = false;
                micBtn.classList.remove('listening');
                micBtn.textContent = 'üé§';
                micBtn.title = "Speak to type";
                micBtn.disabled = false; 
                sendBtn.disabled = false; 
                messageInput.focus();
                console.log("[STT] Recognition ended.");
            };
        } else {
            micBtn.style.display = 'none'; 
            console.warn('[STT] Speech Recognition API not supported in this browser.');
        }


        // Event Listeners
        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        messageInput.addEventListener('input', adjustTextareaHeight);

        ttsToggle.addEventListener('click', toggleTTS);
        settingsBtn.addEventListener('click', showSettings);
        saveBtn.addEventListener('click', saveSettings);
        cancelBtn.addEventListener('click', hideSettings);
        clearHistoryBtn.addEventListener('click', clearChatHistory); // New event listener
        
        settingsModal.addEventListener('click', (e) => {
            if (e.target === settingsModal) { // Click outside modal content
                hideSettings();
            }
        });

        // Initialize app
        async function init() {
            console.log("App initializing...");
            loadSettingsAndHistory(); // Load settings and history first
            ttsToggle.classList.toggle('active', appState.ttsEnabled);
            renderChatHistory(); // Render loaded history or initial messages
            await vits.initialize(); // Ensure VITS/voices are ready (modified initialize)
            
            messageInput.focus();
            
            // Initial messages are now handled by renderChatHistory based on loaded state.
            // This timeout message only if there's no API key and no history is loaded.
            if (!appState.apiKey && appState.messages.length === 0) {
                 addMessage('üí° Welcome! Ask a grown-up to click the "Setup" button to enter an OpenRouter API key so we can chat for real! Otherwise, I can only give demo responses.\n\n‚ö†Ô∏è **For Grown-Ups**: If you are running this from a `file:///` URL, API calls might be blocked by browser security (CORS). Running it from a local web server (e.g., `http://localhost/...`) is recommended for full functionality.', 'system', false, false);
            }
            console.log("App initialized.");
        }

        init();
    </script>
</body>
</html>
