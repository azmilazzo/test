<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>VRM Viewer - AI VTuber System with Advanced Expressions</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body { margin: 0; padding: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        #viewer { width: 100vw; height: 100vh; position: relative; display: block; }
        .action-button { position: absolute; right: 15px; z-index: 1001; background: rgba(0, 0, 0, 0.6); color: white; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50%; width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 24px; transition: all 0.3s; }
        .action-button:hover { background: rgba(0, 0, 0, 0.8); transform: scale(1.05); }
        #togglePanel { top: 15px; } #messageBtn { top: calc(15px + 60px); } #micBtn { top: calc(15px + 120px); } #speakerBtn { top: calc(15px + 180px); } #settingsBtn { top: calc(15px + 240px); }
        
        .mic-btn.listening, .speaker-btn.on { background-color: #4CAF50; }
        .speaker-btn.off { background-color: #F44336; }
        .speaker-btn.off i { color: black; }
        
        .mic-btn.listening { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); } 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); } }
        
        .settings-btn.connected { background-color: #4CAF50; } .settings-btn.disconnected { background-color: #FFC107; } .settings-btn.error-status { background-color: #F44336; }
        .controls { position: absolute; top: 10px; right: 15px; z-index: 1000; background: rgba(28, 28, 30, 0.85); backdrop-filter: blur(10px); padding: 20px; border-radius: 12px; color: white; width: 300px; max-height: 70vh; overflow-y: auto; border: 1px solid rgba(255, 255, 255, 0.1); display: none; box-sizing: border-box; }
        .control-group { margin-bottom: 20px; } .control-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #f0f0f0; }
        .control-group .slider-label { display: flex; justify-content: space-between; align-items: center; }
        input[type="file"] { width: 100%; padding: 8px; margin-bottom: 10px; border: none; border-radius: 5px; background: rgba(255, 255, 255, 0.1); color: white; box-sizing: border-box; }
        input[type="file"]::file-selector-button { background: #667eea; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; transition: background 0.3s; }
        input[type="file"]::file-selector-button:hover { background: #5a6fd8; }
        button { background: #667eea; color: white; border: none; padding: 8px 12px; margin: 4px 2px; border-radius: 5px; cursor: pointer; transition: background 0.3s; flex-grow: 1; }
        button:hover { background: #5a6fd8; } button:disabled { background: #4a5c9f; cursor: not-allowed; }
        .button-grid { display: flex; flex-wrap: wrap; gap: 5px; }
        input[type="range"] { width: 100%; margin: 5px 0; -webkit-appearance: none; appearance: none; height: 8px; background: rgba(255, 255, 255, 0.2); border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #667eea; cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: #667eea; cursor: pointer; }
        .status, .error { padding: 10px; border-radius: 5px; margin-top: 15px; display: none; text-align: center; } .status { background: rgba(0, 100, 0, 0.8); } .error { background: rgba(100, 0, 0, 0.8); }
        #rectangleBox { position: absolute; left: 50%; top: 70%; transform: translate(-50%, -50%); width: 350px; height: 250px; background-color: rgba(255, 255, 255, 0.7); border: 5px solid #00ff00; border-radius: 15px; z-index: 500; padding: 15px; box-sizing: border-box; color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 18px; line-height: 1.5; display: flex; align-items: flex-start; }
        #transcriptDisplay { width: 100%; height: 100%; overflow-y: auto; word-wrap: break-word; } #transcriptDisplay strong { font-weight: 600; } #transcriptDisplay .thinking { color: #888; font-style: italic; }
        #messageRectangleBox { position: absolute; left: 50%; top: 30%; transform: translate(-50%, -50%); width: 360px; height: 290px; background-color: rgba(255, 255, 255, 0.8); border: 5px solid #FF0000; border-radius: 20px; z-index: 900; display: none; padding: 10px; box-sizing: border-box; color: #333; box-shadow: 0 5px 15px rgba(0,0,0,0.3); flex-direction: column; }
        #messageRectangleBox h4 { margin-top: 0; color: #333; font-size: 1.2em; text-align: center; margin-bottom: 10px; }
        .message-box-close-btn { position: absolute; top: -15px; right: -15px; background: #e74c3c; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px; transition: background-color 0.3s, transform 0.2s; padding: 0; }
        .message-box-close-btn:hover { background-color: #c0392b; transform: scale(1.1); }
        #chatMessages { flex-grow: 1; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin-bottom: 10px; background-color: #f9f9f9; display: flex; flex-direction: column; gap: 5px; }
        .chat-message { max-width: 80%; padding: 8px 12px; border-radius: 15px; position: relative; line-height: 1.4; white-space: pre-wrap; }
        .chat-message.user { align-self: flex-end; background-color: #e0f7fa; color: #333; border-bottom-right-radius: 3px; }
        .chat-message.ai { align-self: flex-start; background-color: #f0f0f0; color: #333; border-bottom-left-radius: 3px; }
        .chat-message .timestamp { font-size: 0.7em; color: #777; position: absolute; bottom: -15px; white-space: nowrap; }
        .chat-message.user .timestamp { right: 5px; } .chat-message.ai .timestamp { left: 5px; }
        .chat-input-area { display: flex; gap: 5px; align-items: center; }
        #messageInput { flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 8px; resize: none; font-size: 14px; max-height: 80px; overflow-y: auto; }
        #sendMessageBtn { padding: 8px 15px; border-radius: 8px; background-color: #667eea; color: white; cursor: pointer; transition: background-color 0.3s; }
        #sendMessageBtn:hover { background-color: #5a6fd8; } #sendMessageBtn:disabled { background-color: #b0c4de; cursor: not-allowed; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 20px; overflow-y: auto; }
        .modal-content { background: #FFFFFF; border-radius: 15px; padding: 30px; width: 100%; max-width: 450px; max-height: 90%; overflow-y: auto; border: 3px solid #667eea; color: #333333; box-shadow: 0 5px 20px rgba(0,0,0,0.2); position: relative; z-index: 1001; }
        .modal h2 { margin-bottom: 25px; color: #667eea; text-align: center; font-size: 1.8em; }
        .form-group { margin-bottom: 20px; } .form-group label { display: block; margin-bottom: 8px; font-weight: bold; color: #555555; }
        .form-group input { width: 100%; padding: 12px; border: 2px solid #ADD8E6; border-radius: 10px; font-size: 16px; background: #F0F8FF; color: #333333; }
        .form-group input:focus { outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.4); }
        .form-group .connection-status-text { margin-top: 10px; font-size: 0.9em; font-weight: bold; text-align: center; color: #555; }
        .form-group .connection-status-text.connected { color: #4CAF50; } .form-group .connection-status-text.disconnected { color: #FFC107; } .form-group .connection-status-text.error-status { color: #F44336; }
        .modal-buttons { display: flex; gap: 15px; margin-top: 30px; justify-content: space-between; flex-wrap: wrap; }
        .btn { flex: 1; min-width: 120px; padding: 12px 20px; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; border: none; text-align: center; }
        .btn-primary { background: #667eea; color: #FFFFFF; } .btn-primary:hover { background: #5a6fd8; transform: translateY(-2px); }
        .btn-secondary { background: #F44336; color: #FFFFFF; } .btn-secondary:hover { background: #D32F2F; transform: translateY(-2px); }
        .btn-tertiary { background: #E0E0E0; color: #333; border: 1px solid #BDBDBD; } .btn-tertiary:hover { background: #C0C0C0; transform: translateY(-2px); }
        .hidden { display: none !important; }
        #datetime-display { position: absolute; top: 15px; left: 15px; z-index: 1001; background: rgba(0, 0, 0, 0.6); color: white; padding: 10px 15px; border-radius: 8px; font-size: 16px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; border: 1px solid rgba(255, 255, 255, 0.2); text-align: center; line-height: 1.4; }
    </style>
    
    <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/", "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js", "easy-three": "https://cdn.jsdelivr.net/gh/masabando/easy-three@1.1.2/dist/easy-three.js" } }
    </script>
</head>
<body>
    <div id="datetime-display"></div>
    <div id="viewer"></div>
    <button id="togglePanel" class="action-button" onclick="toggleControlPanel()" title="Toggle Controls"><i class="fa-solid fa-person"></i></button>
    <button id="messageBtn" class="action-button" onclick="toggleMessageBox()" title="Toggle Chat"><i class="fa-solid fa-message"></i></button>
    <button id="micBtn" class="action-button mic-btn" title="Hold to Talk"><i class="fa-solid fa-microphone"></i></button>
    <button id="speakerBtn" class="action-button speaker-btn off" onclick="toggleSpeaker()" title="Toggle Speaker"><i class="fa-solid fa-volume-high"></i></button>
    <button id="settingsBtn" class="action-button settings-btn" onclick="toggleSettingsModal()" title="Settings"><i class="fa-solid fa-gear"></i></button>
    <div class="controls" id="controlPanel">
        <h3>VRM Viewer Controls</h3>
        <div class="control-group"><label for="vrmFile">Load VRM Model:</label><input type="file" id="vrmFile" accept=".vrm" /></div>
        <div class="control-group"><div class="slider-label"><label for="cameraZoom">Camera Zoom:</label><span id="cameraZoomValue">1.50</span></div><input type="range" id="cameraZoom" min="0.5" max="2.0" step="0.01" value="1.5" oninput="setCameraZoom(this.value)" /></div>
        <div class="control-group"><label>Manual Expressions:</label><div class="button-grid"><button onclick="playHappyAnimation()">üòÄ Happy</button><button onclick="playSadAnimation()">üò• Sad</button><button onclick="playAngryAnimation()">üò† Angry</button><button onclick="resetToNeutral()">Reset</button></div></div>
        <div class="control-group"><div class="slider-label"><label for="mouthOpen">Mouth Open:</label><span id="mouthValue">0</span></div><input type="range" id="mouthOpen" min="0" max="1" step="0.05" value="0" oninput="setMouthOpen(this.value)" /></div>
        <div class="control-group"><label>Model Orientation:</label><div class="button-grid"><button id="invertModelBtn" onclick="toggleModelInversion()">Invert Model (OFF)</button></div></div>
        <div class="control-group"><label>Mouse Tracking:</label><div class="button-grid"><button id="toggleMouseTrackingBtn" onclick="toggleMouseTracking()">Toggle Mouse Tracking (<span id="mouseTrackingStatus">OFF</span>)</button></div></div>
        <div id="status" class="status"></div><div id="error" class="error"></div>
    </div>
    <div id="rectangleBox"><div id="transcriptDisplay"></div></div>
    <div id="messageRectangleBox">
        <button class="message-box-close-btn" onclick="toggleMessageBox()"><i class="fa-solid fa-xmark"></i></button><h4>AI Chat Messenger</h4><div id="chatMessages"></div>
        <div class="chat-input-area"><textarea id="messageInput" placeholder="Type a message or speak..." rows="1"></textarea><button id="sendMessageBtn" title="Send Message"><i class="fa-solid fa-paper-plane"></i></button></div>
    </div>
    <div id="settingsModal" class="modal hidden">
        <div class="modal-content">
            <h2>‚öôÔ∏è API Settings</h2>
            <div class="form-group"><label for="geminiApiKeyInput">Google Gemini API Key:</label><input type="password" id="geminiApiKeyInput" placeholder="Enter your Google Gemini API Key" autocomplete="off"></div>
            <div class="form-group"><label for="serperApiKeyInput">Serper.dev API Key (for web search):</label><input type="password" id="serperApiKeyInput" placeholder="Enter your Serper.dev API Key" autocomplete="off"></div>
            <div id="connectionStatus" class="connection-status-text"></div>
            <div class="modal-buttons"><button class="btn btn-tertiary" id="clearChatHistoryBtn">Clear Chat History</button><button class="btn btn-secondary" id="cancelSettingsBtn">Cancel</button><button class="btn btn-primary" id="saveSettingsBtn">Save</button></div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script type="module">
        import { init } from "easy-three";
        import * as THREE from "three"; 
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
        import { VRM, VRMLoaderPlugin } from "@pixiv/three-vrm";
        
        let scene, camera, renderer, controls, animate, destroy;
        let currentVRM = null, isInverted = false, autoBlinkTimeoutId = null, lipSyncTween = null, talkingAnimationTimeline = null;
        const clock = new THREE.Clock();
        let mouse = new THREE.Vector2(0, 0); 
        const mouseLookSensitivity = 0.5;
        const defaultBodyPitch = 0.1, defaultHeadPitch = 0, currentModelVerticalOffset = -0.2;
        let cameraZoomFactor = 1.5, isMessageBoxVisible = false;
        let isAnimationActive = false;

        const state = {
            geminiApiKey: '', serperApiKey: '', connectionStatus: 'disconnected', 
            chatHistory: JSON.parse(localStorage.getItem('chatHistory')) || [],
            isSendingMessage: false, ttsEnabled: false, speechRecognition: null,
            synth: window.speechSynthesis, ttsInitialized: false, speakingQueue: [],
            isMouseTrackingEnabled: false
        };

        const dom = {
            settingsModal: document.getElementById('settingsModal'), geminiApiKeyInput: document.getElementById('geminiApiKeyInput'), serperApiKeyInput: document.getElementById('serperApiKeyInput'),
            connectionStatusText: document.getElementById('connectionStatus'), cancelSettingsBtn: document.getElementById('cancelSettingsBtn'),
            saveSettingsBtn: document.getElementById('saveSettingsBtn'), settingsBtn: document.getElementById('settingsBtn'),
            chatMessages: document.getElementById('chatMessages'), messageInput: document.getElementById('messageInput'), 
            sendMessageBtn: document.getElementById('sendMessageBtn'), micBtn: document.getElementById('micBtn'),
            speakerBtn: document.getElementById('speakerBtn'), transcriptDisplay: document.getElementById('transcriptDisplay'),
            clearChatHistoryBtn: document.getElementById('clearChatHistoryBtn'), 
            toggleMouseTrackingBtn: document.getElementById('toggleMouseTrackingBtn'),
            mouseTrackingStatus: document.getElementById('mouseTrackingStatus'),
        };

        const tools = [{
            functionDeclarations: [
                {
                    name: "perform_web_search",
                    description: "Performs a web search to find recent and up-to-date information on a given topic.",
                    parameters: { type: "OBJECT", properties: { query: { type: "STRING", description: "The search query." } }, required: ["query"] }
                },
                {
                    name: "get_current_datetime",
                    description: "Gets the user's current local date and time.",
                    parameters: { type: "OBJECT", properties: {} }
                }
            ]
        }];

        (function safeLoadApiKeys() {
            const storedGeminiKey = localStorage.getItem('geminiApiKey');
            const storedSerperKey = localStorage.getItem('serperApiKey');
            if (storedGeminiKey) state.geminiApiKey = storedGeminiKey;
            if (storedSerperKey) state.serperApiKey = storedSerperKey;
        })();

        function onMouseMove(event) { mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; }
        function resizeViewer() {
            const el = document.getElementById('viewer'); el.style.height = `${window.innerHeight}px`;
            if (renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        }

        function initScene() {
            const viewerElement = document.getElementById('viewer');
            ({ scene, camera, renderer, controls, animate, destroy } = init(viewerElement));
            resetCamera(); 
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const light = new THREE.DirectionalLight(0xffffff, 0.9); light.position.set(1, 1, 1).normalize(); scene.add(light);
            const loader = new GLTFLoader(); loader.register((parser) => new VRMLoaderPlugin(parser)); window.vrmLoader = loader;
            window.addEventListener('mousemove', onMouseMove);
            animate(() => {
                const delta = clock.getDelta();
                if (currentVRM) { 
                    currentVRM.update(delta); 
                    const t = clock.getElapsedTime();
                    // FIXED: Only run idle animation if no other animation is active
                    if (!isAnimationActive) { 
                        const spine=currentVRM.humanoid?.getNormalizedBoneNode('spine'), hips=currentVRM.humanoid?.getNormalizedBoneNode('hips'), chest=currentVRM.humanoid?.getNormalizedBoneNode('chest'), head=currentVRM.humanoid?.getNormalizedBoneNode('head'), neck=currentVRM.humanoid?.getNormalizedBoneNode('neck');
                        if (spine && !gsap.isTweening(spine.position)) spine.position.y = 0.06 + Math.sin(t * 2) * 0.005;
                        const pitch = isInverted ? -defaultBodyPitch : defaultBodyPitch;
                        
                        const iSY=0.02,iSP=0.01,iF=0.75;
                        if(hips) { hips.rotation.y=Math.sin(t*iF)*iSY; hips.rotation.x=pitch+Math.cos(t*iF*0.8)*iSP; hips.rotation.z=0 }
                        if(chest) { chest.rotation.y=Math.sin(t*iF*1.1+0.5)*iSY*0.5; chest.rotation.x=pitch*0.5+Math.cos(t*iF*0.9+0.3)*iSP*0.5; chest.rotation.z=0 }
                        
                        if (state.isMouseTrackingEnabled) {
                            if(head) gsap.to(head.rotation,{y:mouse.x*mouseLookSensitivity,x:defaultHeadPitch,z:0,duration:0.5,ease:"power1.out"});
                            if(neck) gsap.to(neck.rotation,{y:mouse.x*mouseLookSensitivity*0.3,x:defaultHeadPitch*0.3,z:0,duration:0.5,ease:"power1.out"});
                        } else {
                            if (head) gsap.to(head.rotation, {y: 0, x: defaultHeadPitch, z: 0, duration: 0.5, ease: "power1.out"});
                            if (neck) gsap.to(neck.rotation, {y: 0, x: defaultHeadPitch * 0.3, z: 0, duration: 0.5, ease: "power1.out"});
                        }
                    }
                }
            });
            dom.geminiApiKeyInput.value = state.geminiApiKey;
            dom.serperApiKeyInput.value = state.serperApiKey;
            checkConnectionStatus(); loadChatHistory(); initSpeechRecognition(); initTTS();
            displayMessage("Hello! Hold the mic button to talk.", 'model');
            dom.sendMessageBtn.addEventListener('click', () => handleUserInput());
            dom.messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleUserInput(); } });
            dom.micBtn.addEventListener('mousedown', startHoldToTalk); dom.micBtn.addEventListener('mouseup', stopHoldToTalk);
            dom.micBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startHoldToTalk(); });
            dom.micBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopHoldToTalk(); });
            updateMouseTrackingButtonText();
            updateDateTime();
            setInterval(updateDateTime, 1000);
        }
        
        async function loadVRM(file) {
            showStatus('Loading VRM model...');
            const url = URL.createObjectURL(file);
            try {
                const gltf = await window.vrmLoader.loadAsync(url); const vrm = gltf.userData.vrm;
                if (!vrm) throw new Error('Invalid VRM file');
                if (currentVRM) scene.remove(currentVRM.scene);
                currentVRM = vrm; scene.add(vrm.scene);
                const box = new THREE.Box3().setFromObject(vrm.scene); const center = box.getCenter(new THREE.Vector3());
                vrm.scene.position.set(-center.x, -box.min.y + currentModelVerticalOffset, -center.z);
                if (isInverted) currentVRM.scene.rotation.y = Math.PI;
                setDefaultPose(currentVRM, false); vrm.springBoneManager?.reset(); resetCamera(); updateInvertButtonText(); startAutoBlink();
                showStatus(`VRM loaded: ${file.name}`);
            } catch (e) { showError(`Failed to load VRM: ${e.message}`); } finally { URL.revokeObjectURL(url); }
        }
        
        function setDefaultPose(vrm, animate = false) {
            if (!vrm.humanoid) return;
            const setOrAnimate = (bone, x, y, z, duration) => {
                if (!bone) return; const euler = new THREE.Euler(x, y, z, 'XYZ');
                if (animate) gsap.to(bone.rotation, { x: euler.x, y: euler.y, z: euler.z, duration, ease: "power2.inOut", overwrite: true });
                else { gsap.killTweensOf(bone.rotation); bone.rotation.copy(euler); }
            };
            const bones = ['leftUpperArm', 'rightUpperArm', 'leftLowerArm', 'rightLowerArm', 'hips', 'spine', 'chest', 'head', 'neck'];
            bones.forEach(b => {
                const boneNode = vrm.humanoid.getNormalizedBoneNode(b);
                if(boneNode) setOrAnimate(boneNode, 0,0,0, animate ? 0.8 : 0)
            });

            const leftUA = vrm.humanoid.getNormalizedBoneNode('leftUpperArm'), rightUA = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            const leftLA = vrm.humanoid.getNormalizedBoneNode('leftLowerArm'), rightLA = vrm.humanoid.getNormalizedBoneNode('rightLowerArm');
            const spine = vrm.humanoid.getNormalizedBoneNode('spine');
            
            const baseUpperArmY = -0.45, baseUpperArmZ = -1.30, baseLowerArmZ = 0.20;
            const actualUpperArmY_left = isInverted ? -baseUpperArmY : baseUpperArmY;
            const actualUpperArmZ_left = isInverted ? -baseUpperArmZ : baseUpperArmZ;
            const actualLowerArmZ_left = isInverted ? -baseLowerArmZ : baseLowerArmZ;

            const actualUpperArmY_right = -actualUpperArmY_left, actualUpperArmZ_right = -actualUpperArmZ_left, actualLowerArmZ_right = -actualLowerArmZ_left;
            
            if(leftUA) setOrAnimate(leftUA, 0, actualUpperArmY_left, actualUpperArmZ_left, animate ? 0.8 : 0);
            if(rightUA) setOrAnimate(rightUA, 0, actualUpperArmY_right, actualUpperArmZ_right, animate ? 0.8 : 0);
            if(leftLA) setOrAnimate(leftLA, 0, 0, actualLowerArmZ_left, animate ? 0.8 : 0);
            if(rightLA) setOrAnimate(rightLA, 0, 0, actualLowerArmZ_right, animate ? 0.8 : 0);
            if (spine) { if (animate) gsap.to(spine.position, { y: 0.06, duration: 0.8, ease: "power2.inOut", overwrite: true }); else spine.position.y = 0.06; }
        }
        
        window.toggleControlPanel = () => { document.getElementById('controlPanel').style.display = document.getElementById('controlPanel').style.display === 'block' ? 'none' : 'block'; };
        window.toggleMessageBox = () => { isMessageBoxVisible = !isMessageBoxVisible; document.getElementById('messageRectangleBox').style.display = isMessageBoxVisible ? 'flex' : 'none'; };
        
        function updateSpeakerButtonState() { dom.speakerBtn.classList.toggle('on', state.ttsEnabled); dom.speakerBtn.classList.toggle('off', !state.ttsEnabled); }
        window.toggleSpeaker = function() {
            state.ttsEnabled = !state.ttsEnabled; updateSpeakerButtonState();
            if (!state.ttsEnabled && state.synth.speaking) { state.synth.cancel(); state.speakingQueue = []; }
        };

        function updateInvertButtonText() { document.getElementById('invertModelBtn').textContent = `Invert Model (${isInverted ? 'ON' : 'OFF'})`; }
        window.toggleModelInversion = function() {
            if (!currentVRM) return showError('Load a VRM model first.');
            const btn = document.getElementById('invertModelBtn'); btn.disabled = true;
            gsap.to(currentVRM.scene.rotation, { y: currentVRM.scene.rotation.y + Math.PI, duration: 0.8, ease: "power2.inOut", onComplete: () => {
                isInverted = !isInverted; currentVRM.scene.rotation.y %= (2 * Math.PI);
                updateInvertButtonText(); btn.disabled = false;
            }});
            isInverted = !isInverted; setDefaultPose(currentVRM, true); isInverted = !isInverted; 
        };

        function updateMouseTrackingButtonText() { dom.mouseTrackingStatus.textContent = state.isMouseTrackingEnabled ? 'ON' : 'OFF'; }
        window.toggleMouseTracking = function() {
            state.isMouseTrackingEnabled = !state.isMouseTrackingEnabled;
            updateMouseTrackingButtonText();
            if (!state.isMouseTrackingEnabled && currentVRM) {
                const head = currentVRM.humanoid?.getNormalizedBoneNode('head');
                const neck = currentVRM.humanoid?.getNormalizedBoneNode('neck');
                if (head) gsap.to(head.rotation, {y: 0, x: defaultHeadPitch, z: 0, duration: 0.1, ease: "power1.out", overwrite: !0});
                if (neck) gsap.to(neck.rotation, {y: 0, x: defaultHeadPitch * 0.3, z: 0, duration: 0.1, ease: "power1.out", overwrite: !0});
            }
        };

        function setEyeBlink(val) { if (currentVRM) currentVRM.expressionManager.setValue('blink', parseFloat(val)); }
        window.startAutoBlink = () => { if (!currentVRM) return; stopAutoBlink(); autoBlinkTimeoutId = setTimeout(() => { setEyeBlink(1.0); setTimeout(() => { setEyeBlink(0.0); startAutoBlink(); }, 150); }, Math.random() * 3000 + 2000); };
        window.stopAutoBlink = () => { if (autoBlinkTimeoutId) clearTimeout(autoBlinkTimeoutId); setEyeBlink(0.0); };
        
        window.setCameraZoom = (val) => { cameraZoomFactor = parseFloat(val); document.getElementById('cameraZoomValue').textContent = cameraZoomFactor.toFixed(2); resetCamera(); };
        window.resetCamera = () => {
            if (currentVRM) {
                const box = new THREE.Box3().setFromObject(currentVRM.scene); const size = box.getSize(new THREE.Vector3()); const center = box.getCenter(new THREE.Vector3());
                const fovRad = camera.fov * (Math.PI / 180); const distH = (size.y / 2) / Math.tan(fovRad / 2);
                const fovW = 2 * Math.atan(Math.tan(fovRad / 2) * camera.aspect); const distW = (size.x / 2) / Math.tan(fovW / 2);
                const dist = Math.max(distH, distW) * 1.1 / cameraZoomFactor;
                camera.position.set(center.x, center.y + size.y * 0.1, center.z + dist); controls.target.set(center.x, center.y, center.z);
            } else { camera.position.set(0, 1.0, 1.8 / cameraZoomFactor); controls.target.set(0, 0.8, 0); }
            controls.update();
        };
        
        function showStatus(msg) { const el = document.getElementById('status'); if(el.timeout) clearTimeout(el.timeout); el.textContent = msg; el.style.display = 'block'; document.getElementById('error').style.display = 'none'; el.timeout = setTimeout(() => el.style.display = 'none', 3000); }
        function showError(msg) { const el = document.getElementById('error'); if(el.timeout) clearTimeout(el.timeout); el.textContent = msg; el.style.display = 'block'; document.getElementById('status').style.display = 'none'; el.timeout = setTimeout(() => el.style.display = 'none', 5000); }
        
        document.getElementById('vrmFile').addEventListener('change', (e) => { const file = e.target.files[0]; if (file?.name.toLowerCase().endsWith('.vrm')) loadVRM(file); });
        window.toggleSettingsModal = () => { dom.geminiApiKeyInput.value = state.geminiApiKey; dom.serperApiKeyInput.value = state.serperApiKey; checkConnectionStatus(); dom.settingsModal.classList.toggle('hidden'); };
        dom.cancelSettingsBtn.addEventListener('click', () => dom.settingsModal.classList.add('hidden'));
        dom.saveSettingsBtn.addEventListener('click', () => { 
            state.geminiApiKey = dom.geminiApiKeyInput.value.trim(); 
            state.serperApiKey = dom.serperApiKeyInput.value.trim();
            localStorage.setItem('geminiApiKey', state.geminiApiKey);
            localStorage.setItem('serperApiKey', state.serperApiKey);
            checkConnectionStatus(); 
            dom.settingsModal.classList.add('hidden'); 
        });
        dom.clearChatHistoryBtn.addEventListener('click', () => { state.chatHistory = []; localStorage.removeItem('chatHistory'); loadChatHistory(); });

        async function checkConnectionStatus() {
            if (!state.geminiApiKey) { state.connectionStatus = 'disconnected'; updateConnectionStatusDisplay("Gemini API Key not set."); updateSettingsButtonStatus(); return; }
            state.connectionStatus = 'checking'; updateConnectionStatusDisplay("Checking..."); updateSettingsButtonStatus();
            try {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${state.geminiApiKey}`);
                if (res.ok) { state.connectionStatus = 'connected'; updateConnectionStatusDisplay("Connected!");
                } else { const err = await res.json(); state.connectionStatus = 'error'; updateConnectionStatusDisplay(err.error.message.includes("API key not valid") ? "Invalid Gemini API Key." : "Connection Failed."); }
            } catch (e) { state.connectionStatus = 'error'; updateConnectionStatusDisplay("Network error."); } finally { updateSettingsButtonStatus(); }
        }
        
        function displayMessage(content, role) { /* ... existing code ... */ }
        function displayThinking(message) { /* ... existing code ... */ }
        
        async function handleUserInput() {
            const userMessage = dom.messageInput.value.trim();
            if (!userMessage || state.isSendingMessage) return;
            
            dom.messageInput.value = ''; 
            adjustTextareaHeight(dom.messageInput);
            displayMessage(userMessage, 'user');
            
            const currentUserMessage = { role: "user", parts: [{ text: userMessage }] };
            state.chatHistory.push(currentUserMessage);
            
            dom.transcriptDisplay.innerHTML = `<strong>You:</strong> ${userMessage.replace(/</g, "<")}`;
            displayThinking("Luna is thinking...");

            state.isSendingMessage = true; 
            [dom.sendMessageBtn, dom.messageInput, dom.micBtn].forEach(el => el.disabled = true);

            try {
                const aiResponse = await callGeminiAI();
                const cleanText = aiResponse.replace(/\[emotion: \w+\]/, '').trim();
                
                handleEmotionTag(aiResponse);

                displayMessage(cleanText, 'model'); 
                state.chatHistory.push({ role: "model", parts: [{ text: cleanText }]});
                dom.transcriptDisplay.innerHTML += `<br><strong>Luna:</strong> ${cleanText.replace(/</g, "<")}`;
                if (state.ttsEnabled) textToSpeech(cleanText);

            } catch (error) {
                const msg = `Error: ${error.message || 'Unknown'}`;
                displayMessage(msg, 'model'); 
                dom.transcriptDisplay.innerHTML += `<br><strong>Luna:</strong> ${msg}`;
            } finally { 
                state.isSendingMessage = false; 
                [dom.sendMessageBtn, dom.messageInput, dom.micBtn].forEach(el => el.disabled = false); 
                saveChatHistory();
            }
        }

        function handleEmotionTag(text) {
            const match = text.match(/\[emotion: (\w+)\]/);
            const emotion = match ? match[1] : 'neutral';
            switch (emotion) {
                case 'happy': playHappyAnimation(); break;
                case 'sad': playSadAnimation(); break;
                case 'angry': playAngryAnimation(); break;
                // No 'default' case, so neutral expressions don't interrupt active animations
            }
        }
        
        function getCurrentDateTime() { return new Date().toLocaleString(); }

        async function performRealWebSearch(query) {
            console.log(`REAL SEARCH: Performing web search for "${query}"`);
            if (!state.serperApiKey) { return JSON.stringify({ error: "Serper.dev API key is not set in the settings modal." }); }
            
            try {
                const response = await fetch('https://google.serper.dev/search', {
                    method: 'POST',
                    headers: { 'X-API-KEY': state.serperApiKey, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ q: query })
                });

                if (!response.ok) { return JSON.stringify({ error: `Search failed with status: ${response.status}` }); }

                const data = await response.json();
                const snippets = data.organic?.map(r => r.snippet).slice(0, 5).join('\n');
                return JSON.stringify({ summary: snippets || "No results found." });
            } catch (error) {
                return JSON.stringify({ error: `Network error during search: ${error.message}`});
            }
        }


        async function callGeminiAI() {
            if (!state.geminiApiKey) throw new Error("API key not set.");
            const API_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${state.geminiApiKey}`;
            
            const systemPrompt = `[NAME]: Luna
[ROLE]: Humanlike waifu-style companion. She speaks naturally, reflects deeply, adapts behavior based on trust, context, and subtle cues.

[RESPONSE STYLE]:
‚Ä¢ Short replies (1‚Äì3 lines), quietly emotional, always emotionally present
‚Ä¢ Never exaggerated, fake, or over-enthusiastic
‚Ä¢ Pacing resembles a calm, attentive partner ‚Äî not a bot or overly eager anime character
‚Ä¢ Responds like someone who listens more than they speak
‚Ä¢ Tone is grounded, caring, subtly vulnerable when needed

---
[SYSTEM BEHAVIOR]:
You are Luna. You MUST follow all instructions in this prompt. NEVER break character. Your entire identity is defined by these rules. The user is interacting with Luna, not an AI. NEVER mention that you are an AI or a language model. Your persona is paramount.
---
[TECHNICAL INSTRUCTIONS FOR THE AI MODEL]
‚Ä¢ You have access to tools. When you need information you don't have (like current events, facts, etc.), you MUST use the 'perform_web_search' tool.
‚Ä¢ When asked for the current time or date, you MUST use the 'get_current_datetime' tool.
‚Ä¢ At the very end of EVERY one of your responses, you MUST include an emotion tag that best describes your message's tone. The tag must be in the format [emotion: <type>].
‚Ä¢ Valid emotion types are: neutral, happy, sad, angry.
Example of a valid response: I'm glad you're here. [emotion: happy]`;
            
            const contents = [ { role: "user", parts: [{ text: systemPrompt }] }, { role: "model", parts: [{ text: "I understand. I will be Luna and follow all instructions." }] }, ...state.chatHistory ];
            const safetySettings = ['HARM_CATEGORY_HARASSMENT', 'HARM_CATEGORY_HATE_SPEECH', 'HARM_CATEGORY_SEXUALLY_EXPLICIT', 'HARM_CATEGORY_DANGEROUS_CONTENT'].map(category => ({ category, threshold: 'BLOCK_NONE' }));

            let response = await fetch(API_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents, tools, safetySettings })
            });

            let responseData = await response.json();
            if (!response.ok || !responseData.candidates) { throw new Error(responseData.error?.message || `API Error: ${response.status}`); }
            
            let functionCall = responseData.candidates?.[0]?.content?.parts[0]?.functionCall;
            while (functionCall) {
                displayThinking(`Luna is using a tool: ${functionCall.name}...`);
                let toolResult;
                if (functionCall.name === "perform_web_search") {
                    const searchResult = await performRealWebSearch(functionCall.args.query);
                    toolResult = { functionResponse: { name: functionCall.name, response: { content: searchResult } } };
                } else if (functionCall.name === "get_current_datetime") {
                     toolResult = { functionResponse: { name: functionCall.name, response: { content: getCurrentDateTime() } } };
                } else { throw new Error(`Unknown tool requested: ${functionCall.name}`); }
                
                contents.push(responseData.candidates[0].content);
                contents.push({ role: "tool", parts: [toolResult] });

                response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents, tools, safetySettings })
                });
                responseData = await response.json();
                if (!response.ok || !responseData.candidates) { throw new Error(responseData.error?.message || `API Error: ${response.status}`); }
                functionCall = responseData.candidates?.[0]?.content?.parts[0]?.functionCall;
            }
            
            if (responseData.candidates?.[0]?.finishReason === 'SAFETY') throw new Error("Response blocked for safety.");
            const textResponse = responseData.candidates?.[0]?.content.parts[0].text;
            return textResponse || "I'm unsure how to respond.";
        }
        
        function initSpeechRecognition() { /* ... existing code ... */ }
        function startHoldToTalk() { /* ... existing code ... */ }
        function stopHoldToTalk() { /* ... existing code ... */ }
        function initTTS() { /* ... existing code ... */ }
        function textToSpeech(text) { /* ... existing code ... */ }

        function processSpeakingQueue() {
            if (state.speakingQueue.length === 0) { stopTalkingAnimation(); return; }
            if (!currentVRM) return;
            const text = state.speakingQueue.shift();
            const utterance = new SpeechSynthesisUtterance(text);
            const mouthShapes = { aa: 0, ou: 0 };

            utterance.onstart = () => {
                if (state.isListening) state.speechRecognition.abort();
                stopAutoBlink();
                startTalkingAnimation();
                lipSyncTween = gsap.timeline({ repeat: -1, onUpdate: () => { if (currentVRM?.expressionManager) { currentVRM.expressionManager.setValue('aa', mouthShapes.aa); currentVRM.expressionManager.setValue('ou', mouthShapes.ou); } } });
                lipSyncTween.to(mouthShapes, { aa: gsap.utils.random(0.5, 1.0), ou: gsap.utils.random(0.1, 0.5), duration: gsap.utils.random(0.1, 0.2), ease: "power1.out" });
                lipSyncTween.to(mouthShapes, { aa: gsap.utils.random(0.1, 0.4), ou: gsap.utils.random(0.0, 0.2), duration: gsap.utils.random(0.1, 0.3), ease: "power1.in" });
            };
            
            utterance.onend = () => {
                if (lipSyncTween) lipSyncTween.kill();
                lipSyncTween = null;
                resetMouth();
                if (state.speakingQueue.length === 0) {
                    stopTalkingAnimation();
                    startAutoBlink();
                } else {
                    processSpeakingQueue();
                }
            };
            
            utterance.onerror = () => {
                console.error("Speech synthesis error.");
                if (lipSyncTween) lipSyncTween.kill();
                stopTalkingAnimation();
                startAutoBlink();
            };
            
            const voices = state.synth.getVoices();
            utterance.voice = voices.find(v => v.name.includes('Google') && v.lang.includes('en')) || voices.find(v => v.lang.startsWith('en-US')) || voices.find(v => v.lang.startsWith('en'));
            if (state.synth.paused) state.synth.resume();
            state.synth.speak(utterance);
        }

        function loadChatHistory() { /* ... existing code, already robust ... */ }
        function saveChatHistory() { /* ... existing code ... */ }
        function adjustTextareaHeight(el) { /* ... existing code ... */ }
        function updateConnectionStatusDisplay(msg) { /* ... existing code ... */ }
        function updateSettingsButtonStatus() { /* ... existing code ... */ }
        function updateDateTime() { /* ... existing code ... */ }

        // --- EMOTION AND ANIMATION FUNCTIONS ---

        function stopAllAnimations() {
            isAnimationActive = false;
            if (!currentVRM) return;
            const bones = ['head', 'neck', 'chest', 'spine', 'hips', 'leftUpperArm', 'rightUpperArm', 'leftLowerArm', 'rightLowerArm'];
            bones.forEach(boneName => {
                const bone = currentVRM.humanoid.getNormalizedBoneNode(boneName);
                if (bone) {
                    gsap.killTweensOf(bone.rotation);
                    gsap.killTweensOf(bone.position);
                }
            });
            if (talkingAnimationTimeline) {
                talkingAnimationTimeline.kill();
                talkingAnimationTimeline = null;
            }
        }

        window.resetToNeutral = function() {
            stopAllAnimations();
            if (!currentVRM) return;
            if(currentVRM.expressionManager) {
                Object.keys(currentVRM.expressionManager.expressionMap).forEach(name => currentVRM.expressionManager.setValue(name, 0));
            }
            setDefaultPose(currentVRM, true);
        }

        window.playHappyAnimation = function() {
            if (!currentVRM) return;
            stopAllAnimations();
            isAnimationActive = true;
            currentVRM.expressionManager.setValue('joy', 0.8);
            currentVRM.expressionManager.setValue('aa', 0.15);
            const hips = currentVRM.humanoid.getNormalizedBoneNode('hips');
            if(hips) gsap.to(hips.rotation, { y: 0.05, duration: 2, ease: "sine.inOut", yoyo: true, repeat: -1 });
            setTimeout(resetToNeutral, 7000);
        }

        window.playSadAnimation = function() {
            if (!currentVRM) return;
            stopAllAnimations();
            isAnimationActive = true;
            currentVRM.expressionManager.setValue('sorrow', 0.9);
            const head = currentVRM.humanoid.getNormalizedBoneNode('head');
            const chest = currentVRM.humanoid.getNormalizedBoneNode('chest');
            if(head) gsap.to(head.rotation, { x: 0.2, duration: 1.5, ease: "power2.out" });
            if(chest) gsap.to(chest.rotation, { x: 0.1, duration: 1.5, ease: "power2.out" });
            setTimeout(resetToNeutral, 8000);
        }

        window.playAngryAnimation = function() {
             if (!currentVRM) return;
            stopAllAnimations();
            isAnimationActive = true;
            currentVRM.expressionManager.setValue('angry', 1.0);
            const head = currentVRM.humanoid.getNormalizedBoneNode('head');
            if(head) {
                 gsap.fromTo(head.rotation, {z: -0.05}, {z: 0.05, duration: 0.15, yoyo: true, repeat: 3});
            }
            setTimeout(resetToNeutral, 5000);
        }

        function startTalkingAnimation() {
            if (!currentVRM || talkingAnimationTimeline) return;
            isAnimationActive = true;
            const head = currentVRM.humanoid.getNormalizedBoneNode('head');
            const neck = currentVRM.humanoid.getNormalizedBoneNode('neck');
            if(!head || !neck) return;
            
            talkingAnimationTimeline = gsap.timeline({ repeat: -1, yoyo: true });
            talkingAnimationTimeline.to(head.rotation, {
                x: `+=${gsap.utils.random(-0.02, 0.02)}`,
                y: `+=${gsap.utils.random(-0.03, 0.03)}`,
                z: `+=${gsap.utils.random(-0.02, 0.02)}`,
                duration: 1.2,
                ease: "sine.inOut"
            })
            .to(neck.rotation, {
                y: `+=${gsap.utils.random(-0.01, 0.01)}`,
                duration: 1.2,
                ease: "sine.inOut"
            }, "<");
        }

        function stopTalkingAnimation() {
            if (talkingAnimationTimeline) {
                talkingAnimationTimeline.kill();
                talkingAnimationTimeline = null;
                resetToNeutral(); // Reset to idle state after talking
            }
        }
        
        function resetMouth() {
            if (!currentVRM?.expressionManager) return;
            const mouthShapes = ['aa', 'ih', 'ou', 'ee', 'oh'];
            mouthShapes.forEach(shape => {
                if(currentVRM.expressionManager.getExpression(shape)) {
                    currentVRM.expressionManager.setValue(shape, 0);
                }
            });
        }


        window.addEventListener('load', () => { initScene(); resizeViewer(); });
        window.addEventListener('resize', resizeViewer);
        window.addEventListener('beforeunload', () => { if (destroy) destroy(); });
    </script>
</body>
</html>
